(def input (slurp "input1.txt"))
input
(require clojure.string/split-lines :as split-lines)
(require '(clojure.string [split-lines :as splitLines]))
(clojure.string/split-lines input)
(require [clojure.string :as str])
(require '[clojure.string :as str])
(str/split-lines input)
(require '[clojure.string/split-lines :as splitLines])
exit
(load-file "src/aoc/day1/solve.clj")
(main)
(-main)
input
(input)
(def in (slurp "src/aoc/day1/input1.txt"))
(def in (slurp "input1.txt"))
in
(load-file "src/aoc/day1/solve.clj")
(println @input)
(load-file "src/aoc/day1/solve.clj")
(-main)
(-main 1 2)
exit
(def input (slurp "input1.txt"))
input
(require '[clojure.string :as string])
string/split-lines
(string/split-lines input)
(def inputN (string/split-lines input))
inputN
(println inputN)
(use 'clojure.string')
(use 'clojure.string)
(split-lines input)
inputN
(map #(Integer/parseInt %) inputN)
(def inputIntegers (map #(Integer/parseInt %) inputN))
inputIntegers
(println inputIntegers)
(prn inputIntegers)
(use 'clojure.math)
(use 'clojure.math.combinatorics)
(add-dependency [org.clojure/math.combinatorics "0.1.6"]
)
(frequencies "aabbdsdsbb")
(type "hello")
exit
(def input (slurp "input1.txt"))
input
(def input (slurp "./src/aoc/day2/input"))
input
exit
(get "hello" 0)
(= (get "hello" 0) "h")
(= (str(get "hello" 0)) "h")
(= (str(get "hello" 5)) "h")
(subs "hello" 0 1)
(subs "h:" 0 1)
exit
(repeat [1 2 3 4] 2)
(repeat 3 [1 2 3])
(flat (repeat 3 [1 2 3]))
(flatten (repeat 3 [1 2 3]))
exit
(def a "byr:ewewew hcl:332")
(re-matches #"(byr|hcl):*" a)
(re-matches #"(byr|hcl):*" "byr:eew")
(re-matches #"byr:*" "byr:eew")
(re-matches #"byr:(.*)" "byr:eew")
(re-matches #"(.*):*" "byr:eew")
(re-matches #"(byr):*" "byr:eew")
(re-matches #"^(byr):*" "byr:eew")
(re-matches #"(.byr):*" "byr:eew")
(re-matches #"([byr]:)*" "byr:eew")
(re-matches #"(.[byr]:)*" "byr:eew")
(re-matches #"(.[byr]):*" "byr:eew")
(re-matches #"(.(byr)):*" "byr:eew")
(re-find #"byr|hcl" "byr:eew hcl:ewew")
(re-find #"(byr|hcl)" "byr:eew hcl:ewew")
(re-find #"*(byr|hcl)" "byr:eew hcl:ewew")
(re-find #"(byr|hcl)" "byr:eew hcl:ewew")
(re-find #"(byr|hcl):" "byr:eew hcl:ewew")
(re-find #"byr|hcl" "byr:eew hcl:ewew")
(re-find #"(byr|hcl):" "byr:eew hcl:ewew")
(re-matches #"(byr|hcl):" "byr:eew hcl:ewew")
(re-match #"(byr|hcl):" "byr:eew hcl:ewew")
(re-find #"(byr|hcl):" "byr:eew hcl:ewew")
(re-find #"(byr|hcl):*" "byr:eew hcl:ewew")
(re-find #"(byr|hcl):.+*" "byr: hcl:ewew")
(re-find #"(byr|hcl):.+" "byr: hcl:ewew")
(re-find #"(byr|hcl):" "byr: hcl:ewew")
(re-find #"[byr|hcl]:" "byr: hcl:ewew")
(re-find #"*(byr|hcl):" "byr: hcl:ewew")
(re-find #".*(byr|hcl):" "byr: hcl:ewew")
(re-find #".*(byr|hcl):\S+" "byr: hcl:ewew")
(re-find #".*(byr|hcl):\S+" "byr:dsds hcl:ewew")
(re-find #"(byr|hcl):\S+" "byr:dsds hcl:ewew")
(re-find #".(byr|hcl):\S+" "byr:dsds hcl:ewew")
(re-find #".*(byr|hcl):\S+" "byr:dsds hcl:ewew")
(re-find #"?(byr|hcl):\S+" "byr:dsds hcl:ewew")
(re-find #".?(byr|hcl):\S+" "byr:dsds hcl:ewew")
(re-find #".*(byr|hcl):\S+" "byr:dsds hcl:ewew")
(re-find #"*(byr|hcl):\S+" "byr:dsds hcl:ewew")
(re-find #"(byr|hcl):\S+" "byr:dsds hcl:ewew")
(re-find #".(byr|hcl):\S+" "byr:dsds hcl:ewew")
(re-find #"?(byr|hcl):\S+" "byr:dsds hcl:ewew")
(re-find #".?(byr|hcl):\S+" "byr:dsds hcl:ewew")
(re-find #"*?(byr|hcl):\S+" "byr:dsds hcl:ewew")
(re-find #"\s?(byr|hcl):\S+" "byr:dsds hcl:ewew")
(re-find #"[\s\n]?(byr|hcl):\S+" "byr:dsds hcl:ewew")
(re-find #"(byr|hcl):\S+" "byr:dsds hcl:ewew")
(re-seq #"(byr|hcl):\S+" "byr:dsds hcl:ewew")
(re-seq #"(byr|hcl):\S+" "byr:dsds hcl:ewew\nEEwewe:ewew")
(re-seq #"(byr|hcl|ecl):\S+" "byr:dsds hcl:ewew\nEEwewe:ewew")
(re-seq #"(byr|hcl|ecl):\S+" "byr:dsds hcl:ewew\necl:ewew")
(count (re-seq #"(byr|hcl|ecl):\S+" "byr:dsds hcl:ewew\necl:ewew"))
exit
(count "hello")
(and (=1 1) (=2 1) (=1 1))
(and (=1 1) (=2 1))
(and (= 1 1) (= 2 1))
(and (= 1 1) (= 2 1) (= 3 1))
(and (= 1 1) (= 1 1) (= 3 1))
(and (= 1 1) (= 1 1) (= 1 1))
(Integer/parseInt "123")
(subs "123cm" -1 -2)
(re-matches #"^#[a-f0-9]{6}" "#123456")
(re-matches #"^#[a-f0-9]{6}" "123456")
(re-matches #"amb|blu|brn|gry|grn|hzl|oth" "aa")
(re-matches #"amb|blu|brn|gry|grn|hzl|oth" "amb")
(re-matches #"\d{9}" "012")
(re-matches #"\d{9}" "000000001")
(re-matches #"\d{9}" "0000000011")
(subs "163cm" 0 (- (count "163cm") 2))
(subs "163cm"  (- (count "163cm") 2) (count "163cm")
(subs "163cm"  (- (count "163cm") 2) (count "163cm"))
(re-matches #"^#[a-f0-9]{6}" "12ds3456")
(re-matches #"^#[a-f0-9]{6}" "dasd232")
exit
(first "ERT")
(rest "ERT")
(rest "F")
(empty? ())
(max (1 2 3))
max
(require [clojure.set :as set])
(require [clojure.string :as string])
(def a #{123 124})
a
(contains? a 111)
(contains? a 123)
(re-seq #"\w+" "abcded")
(re-seq #"\w" "abcded")
(conj "a" (
(conj "a" #{:b :c})
(conj #{:a :b :c} "d")
(conj #{a b c} "d"}
(conj #{a b c} "d")
(conj #{"a" "b"} "d")
(conj #{"a" "b"} "b")
(reduce #(conj %1 (re-seq #"\w" %2)) #{} ("ab" "ac"))
(conj #{"a" "b"} ("a" "c"))
(concat #{"a" "b"} ("a" "c"))
(concat #{"a" "b"} '("a" "c"))
(conj #{"a" "b"} '("a" "c"))
(conj #{"a" "b"} (set ("a" "c")))
(conj #{"a" "b"} (set '("a" "c")))
(conj #{"a" "b"} "a" "c")
(set (1 2 3))
(into #{} (1 2 1))
(into #{} '(1 2 1))
(def a (1 2 3))
(def a '(1 2 3))
a
(into #{} 'a)
(into #{} a)
(clojure.string/split-line "a\nb")
(clojure.string/split-lines "a\nb")
(cons "a" {})
(cons [a 1] {})
(cons [:a 1] {})
(cons "a" ("b" "c"))
(cons "a" '("b" "c"))
(conj '("b" "c") "a")
(def bag "light red bags contain 1 bright white bag, 2 muted yellow bags.")
bag
(re-seq #"\w+" bag)
(re-seq #"(\w+) contain" bag)
(re-seq #"^(\w+) contain" bag)
(re-seq #"(.\w+) contain" bag)
(re-seq #"(\S+) contain" bag)
(re-seq #"(\S+) contain*" bag)
(re-seq #"(\S+)" bag)
(re-seq #"(\S+) contain" bag)
(re-seq #"(\S*)" bag)
(re-seq #"(\S+)" bag)
(re-seq #"(^\S+)" bag)
(re-seq #"(^\S+)*" bag)
(re-seq #"^(\S+)*" bag)
(re-seq #"^(\S+) contain" bag)
(re-seq #"(\S+) contain" bag)
(re-seq #"(\w+) contain" bag)
(re-seq #"(\W+) contain" bag)
(re-seq #"(\w+) contain" bag)
(re-seq #"(\S+) contain" bag)
(re-seq #"(\S+)" bag)
(re-seq #"(\w+)" bag)
(re-seq #"(\W+)" bag)
(re-seq #"(\w+)" bag)
(re-seq #"(\s+)" bag)
(re-seq #"(\S+)" bag)
bag
(re-seq #"\w+" bag)
(re-seq #"^(\w+)*$" bag)
(re-seq #"^(\w+)\S*$" bag)
(re-seq #"^(\w+)\S+$" bag)
(re-seq #"^(\w+)\S*" bag)
(re-seq #"^(\w+)" bag)
(re-seq #"(\w+)" bag)
(re-seq #"(\w+contain)" bag)
(re-seq #"(\w+\ contain)" bag)
(re-seq #"(\w+contain)\ contain" bag)
(re-seq #"(\w+)\ contain" bag)
(re-seq #"(\S+)\ contain" bag)
(re-seq #"(\w+|\W+)\ contain" bag)
(re-seq #"(?!.*contain)" bag)
(re-seq #"(*contain)" bag)
(re-seq #"(.*contain)" bag)
(re-seq #"(.*)contain" bag)
(re-seq #"(.*)\ contain" bag)
(re-seq #"(.*)\ bags contain" bag)
(re-seq #"(.*)\ bags contain\ (.*)," bag)
(re-seq #"(.*)\ contain\ (.*)," bag)
(re-seq #"(.*)\ contain\ (.*)" bag)
(re-seq #"(.*)\ bags" "bright hello bags")
(re-seq #"," "2 mirrored olive bags, 2 drab violet bags.
")
(clojure.string/split #"," "2 mirrored olive bags, 2 drab violet bags.")
(clojure.string/split "2 mirrored olive bags, 2 drab violet bags." #",")
(re-seq #"(\d+) (.*)\ bags" "2 mirrored olive bags")
(reduce + [1, 2, 3])
(->> (slurp "01.txt"))
exit
(->> [1, 2, 3]
(reduce +))
exit
